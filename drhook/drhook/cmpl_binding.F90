! (C) Copyright 2014- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

SUBROUTINE CMPL_RECV(KBUF,KCOUNT,KTYPE,KSOURCE,KTAG,KCOMM,&
 &KSYNC,KBLOCK,KRCOUNT,KRFROM,KRTAG,KERROR)
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE MPL_MODULE
IMPLICIT NONE
INTEGER KCOUNT,KTYPE,KSOURCE,KTAG,KCOMM
INTEGER KRCOUNT,KRFROM,KRTAG,KERROR,KSYNC,KBLOCK
INTEGER(KIND=JPIM) :: KBUF(*)
INTEGER,EXTERNAL :: CONVIN,CONVOUT
INTEGER ILENB,ILEN
ILENB=CONVIN(KCOUNT,KTYPE)
IF(KSOURCE > 0) THEN
  IF(KTAG /= -1) THEN
    CALL MPL_RECV(KBUF(1:ILENB),KSOURCE=KSOURCE,KTAG=KTAG,&
     KFROM=KRFROM,KRECVTAG=KRTAG,KOUNT=ILEN,KERROR=KERROR)
  ELSE
    CALL MPL_RECV(KBUF(1:ILENB),KSOURCE=KSOURCE,&
     KFROM=KRFROM,KRECVTAG=KRTAG,KOUNT=ILEN,KERROR=KERROR)
  ENDIF
ELSE
  IF(KTAG /= -1) THEN
    CALL MPL_RECV(KBUF(1:ILENB),KTAG=KTAG,&
     KFROM=KRFROM,KRECVTAG=KRTAG,KOUNT=ILEN,KERROR=KERROR)
  ELSE
    CALL MPL_RECV(KBUF(1:ILENB),&
     KFROM=KRFROM,KRECVTAG=KRTAG,KOUNT=ILEN,KERROR=KERROR)
  ENDIF
ENDIF
KRCOUNT=CONVOUT(ILEN,KTYPE)
END SUBROUTINE CMPL_RECV

SUBROUTINE CMPL_SEND(KBUF,KCOUNT,KTYPE,KDEST,KTAG,KCOMM,&
 &KSYNC,KBLOCK,KERROR)
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE MPL_MODULE
IMPLICIT NONE
INTEGER KCOUNT,KTYPE,KTAG,KCOMM,KSYNC,KBLOCK,KDEST
INTEGER KERROR
INTEGER KBUF(*)
INTEGER,EXTERNAL :: CONVIN,CONVOUT
INTEGER ILEN
ILEN=CONVIN(KCOUNT,KTYPE)
CALL MPL_SEND(KBUF(1:ILEN),KDEST=KDEST,KTAG=KTAG,KERROR=KERROR)
END SUBROUTINE CMPL_SEND

SUBROUTINE CMPL_BROADCAST(KBUF,KCOUNT,KTYPE,KROOT,KTAG,KCOMM,&
 &KSYNC,KBLOCK,KERROR)
USE MPL_MODULE
IMPLICIT NONE
INTEGER KCOUNT,KTYPE,KTAG,KCOMM,KSYNC,KBLOCK,KROOT
INTEGER KERROR
INTEGER KBUF(*)
INTEGER,EXTERNAL :: CONVIN,CONVOUT
INTEGER ILEN
ILEN=CONVIN(KCOUNT,KTYPE)
CALL MPL_BROADCAST(KBUF(1:ILEN),KROOT=KROOT,KTAG=KTAG,KERROR=KERROR)
END SUBROUTINE CMPL_BROADCAST

SUBROUTINE CMPL_ABORT(CDMESS)
USE MPL_MODULE
IMPLICIT NONE
CHARACTER(LEN=*) CDMESS
CALL MPL_ABORT(CDMESS)
END SUBROUTINE CMPL_ABORT

SUBROUTINE CMPI_ABORT(KRC)
USE MPL_MPIF, ONLY : MPI_COMM_WORLD
IMPLICIT NONE
INTEGER,INTENT(IN) :: KRC
INTEGER :: IRET
CALL MPI_ABORT(MPI_COMM_WORLD,KRC,IRET)
END SUBROUTINE CMPI_ABORT

SUBROUTINE CMPL_INIT(LDTRMSG,KERROR)
USE MPL_MODULE
IMPLICIT NONE
LOGICAL LDTRMSG
INTEGER KERROR
CALL MPL_INIT(KERROR=KERROR,LDINFO=.FALSE.)
END SUBROUTINE CMPL_INIT

FUNCTION CMPL_NPROC()
USE MPL_MODULE
IMPLICIT NONE
INTEGER CMPL_NPROC
CMPL_NPROC=MPL_NPROC()
END FUNCTION CMPL_NPROC

FUNCTION CMPL_MYRANK()
USE MPL_MODULE
IMPLICIT NONE
INTEGER CMPL_MYRANK
CMPL_MYRANK=MPL_MYRANK()
END FUNCTION CMPL_MYRANK

SUBROUTINE CMPL_BARRIER(KERROR)
USE MPL_MODULE
IMPLICIT NONE
INTEGER KERROR
CALL MPL_BARRIER(KERROR=KERROR)
END SUBROUTINE CMPL_BARRIER

SUBROUTINE CMPL_END(KERROR)
USE MPL_MODULE
IMPLICIT NONE
INTEGER KERROR
CALL MPL_END(KERROR=KERROR)
END SUBROUTINE CMPL_END

SUBROUTINE CMPL_GETARG(KARGNO, CDARG)
USE MPL_MODULE
IMPLICIT NONE
INTEGER KARGNO
CHARACTER(LEN=*) CDARG
CALL MPL_GETARG(KARGNO, CDARG)
END SUBROUTINE CMPL_GETARG

FUNCTION CMPL_IARGC()
USE MPL_MODULE
IMPLICIT NONE
INTEGER CMPL_IARGC
CMPL_IARGC = MPL_IARGC()
END FUNCTION CMPL_IARGC

FUNCTION MPE_MYRANK()
USE MPL_MODULE
IMPLICIT NONE
INTEGER MPE_MYRANK
MPE_MYRANK=MPL_MYRANK()
END FUNCTION MPE_MYRANK

SUBROUTINE MPEI_ABORT(CDMESS)
USE MPL_MODULE
IMPLICIT NONE
CHARACTER(LEN=*) CDMESS
CALL MPL_ABORT()
END SUBROUTINE MPEI_ABORT
